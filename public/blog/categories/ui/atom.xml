<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ui | The Only Lars]]></title>
  <link href="http://theonlylars.com/blog/categories/ui/atom.xml" rel="self"/>
  <link href="http://theonlylars.com/"/>
  <updated>2015-10-18T22:46:27-05:00</updated>
  <id>http://theonlylars.com/</id>
  <author>
    <name><![CDATA[Lars Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building Twitter #music's EQ Slider]]></title>
    <link href="http://theonlylars.com/blog/2013/05/14/rebuilding-twitter-number-musics-eq-slider/"/>
    <updated>2013-05-14T20:55:00-05:00</updated>
    <id>http://theonlylars.com/blog/2013/05/14/rebuilding-twitter-number-musics-eq-slider</id>
    <content type="html"><![CDATA[<p>Semi-recently, Twitter came out with a cool new music app to discovery new music on (get ready for it) Twitter. They aptly named their new chicklet “#music”. Visually, <a href="https://itunes.apple.com/us/app/twitter-music/id625541612?mt=8">#music</a> is a very, <em>very</em> cool app. Everything is custom: transitions, collection views, collection view selection animations, media player controls, and one very cool volume slider. If you don’t have an Rdio or Spotify subscription, you probably don’t see anything cool about the media player’s volume slider, but when you have one of the aforementioned subscriptions, the slider turns into a full-on 2-channel equalizer. It’s <em>very</em> cool.</p>

<p>So I had to build it - and now I’m going to show you how I built it so you can build something similar. This <em>isn’t</em> a full-on tutorial, but some generics behind building it with some code samples.</p>

<h2 id="larsbar">LARSBar</h2>
<p>The final product I’ve created is available as <a href="https://github.com/larsacus/LARSBar"><code>LARSBar</code> on GitHub</a> under the MIT license. Ignore the name. Seriously, despite trying to move away from my name as a prefix, my friends at work penned the name for this control when I showed it to them, and I couldn’t come up with anything better.</p>

<h2 id="design">Design</h2>
<p>When I first start a new UI component. I take a step back and look at the big picture of what it is I’m going to be building. This is what we’re going to be building if you haven’t seen the app:</p>

<p>A Screenshot of Twitter’s EQ Volume Slider:</p>

<p><img class="center" src="/images/larsbar/colored.png"></p>

<p>Before I begin, I ask myself a couple of questions to help me plan and not waste time (note this is just implementation, designing a component involves a whole different set of usability questions):
<!-- more --></p>

<h3 id="questions">Questions</h3>
<ol>
  <li>What is this piece of UI doing?</li>
  <li>How is this UI going to be used?</li>
  <li>Does this control look like anything that has been done before?</li>
  <li>If yes, can you use that thing to make your life easier?</li>
</ol>

<p>In our case, this particular piece of UI is going to be both accepting values for the volume from the user (and be able to be set programmatically) and accepting values for the EQ level for two channels. Also, this control looks strikingly similar to your standard <code>UISlider</code> that Apple has already built and extensively tested. So we’re going to try and reuse <code>UISlider</code> in order to make our lives a little easier.</p>

<p>If you look closely at Twitter’s version, I don’t think they are using a <code>UISlider</code> subclass. You can test this by grabbing the slider thumb grabber and moving it slowly back and forth. You’ll notice the slider thumb stutter even when you move it slowly. <code>UISlider</code> does not do that, so we’re going to be using <code>UISlider</code> as our base. <code>UISlider</code> also easily supports customization via <code>UIAppearance</code>. Double-win.</p>

<p>We also don’t need the slider EQ lights to respond to touch, so we are going to use the lightweight <code>CALayer</code> for each of the lights.</p>

<h3 id="construction-plan">Construction Plan</h3>
<p>In order to build this tool, there are some basic steps that need to happen in order to make this turn out the way we both functionally and visually want:</p>

<ol>
  <li>Layout two rows of discrete lights</li>
  <li>Update each individual light based on a “level” property</li>
  <li>Have different “levels” light up each light at a different color</li>
</ol>

<h2 id="positioning-the-lights">Positioning the Lights</h2>
<p>Our first step is to simply layout two rows of lights above and below the slider track. We’ll also need some way to store the layers being used for the lights themselves. We’ll create two storage arrays in order to store our created layers:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">leftChannelLightLayers</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">rightChannelLightLayers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>In order to populate and layout our layers, we’ll need to find a mechanism that will allow us to update our layout based on changes of the size of the control. <code>layoutSubviews</code> sounds like a perfect candidate for laying out our lights.</p>

<p>We first need to calculate how many lights that are going to fit horizontally in our layout. To do this, we’ll define a base size for our light layers, then take the width of the control and divide to get how many we need to layout:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">NSInteger</span> <span class="n">numberOfLights</span> <span class="o">=</span> <span class="n">floorf</span><span class="p">((</span><span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span><span class="o">-</span><span class="n">TOLTargetLightPadding</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">TOLLightLayerSize</span><span class="p">.</span><span class="n">width</span> <span class="o">+</span> <span class="n">TOLTargetLightPadding</span><span class="p">));</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">);</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">lightWidth</span> <span class="o">=</span> <span class="n">TOLLightLayerSize</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CGFloat</span> <span class="n">actualPadding</span> <span class="o">=</span> <span class="n">roundf</span><span class="p">((</span><span class="n">totalWidth</span> <span class="o">-</span> <span class="n">numberOfLights</span><span class="o">*</span><span class="n">lightWidth</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">numberOfLights</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The <code>TOL</code> prefixed variable are constants I have defined to customize the appearance of the control.</p>

<p>This gives us 1. the number of lights being laid out and 2. the actual padding that needs to exist between them. From here we can assign each layer the appropriate frame based on the above information (in this case we’re calculating the center point for each layer):</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="bp">NSUInteger</span> <span class="n">lightNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lightNum</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">numberOfLights</span><span class="p">;</span> <span class="n">lightNum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">x</span> <span class="o">=</span> <span class="n">actualPadding</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lightNum</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">lightWidth</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">lightNum</span> <span class="o">+</span> <span class="p">(</span><span class="n">lightWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">centerLineHeight</span> <span class="o">=</span> <span class="n">CGRectGetHeight</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">yOffset</span> <span class="o">=</span> <span class="mf">2.f</span> <span class="o">+</span> <span class="n">TOLLightLayerSize</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">topCenter</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">centerLineHeight</span> <span class="o">-</span> <span class="n">yOffset</span><span class="p">);</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">bottomCenter</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">centerLineHeight</span> <span class="o">+</span> <span class="n">yOffset</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">[</span><span class="nb">self</span> <span class="nl">layoutLightNumber</span><span class="p">:</span><span class="n">lightNum</span>
</span><span class='line'>                 <span class="nl">center</span><span class="p">:</span><span class="n">topCenter</span>
</span><span class='line'>           <span class="nl">storageArray</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">leftChannelLightLayers</span>
</span><span class='line'>            <span class="nl">totalLights</span><span class="p">:</span><span class="n">numberOfLights</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** layout bottom lights in the same way */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>The method in this code block sets some properties on the layer based on its position in the array. The only thing it does here for positioning is set the layer’s <code>position</code> property to the <code>center</code> variable fed into the method. Much of what is going on inside <code>layoutLightNumber:center:storageArray:totalLights</code> are performance optimizations that you can check out in the full source if you’re interested.</p>

<h2 id="building-a-light">Building a Light</h2>
<p><img class="right" src="/images/larsbar/zoomed.png">
<img class="right" src="/images/larsbar/zoomed-inactive.png">
We have some more requirements for the light itself than we did for the layout. Each light needs to have a different glow color depending on where it is in the x-direction, so it needs to be dynamic. I would also like for the light to animate the change in light color when its state is changed. If you look at the Twitter #music app, you’ll also notice that the base color of the light when it is off is two different colors depending on if it is in front of or behind the slider thumb grabber.</p>

<p>A Screenshot of Twitter’s EQ Slider in the Inactive State:
<img class="center" src="/images/larsbar/darkened.png"></p>

<p>This would be very difficult and time-consuming to do with assets. So we’re going to build it using CoreGraphics.</p>

<h3 id="coregraphics">CoreGraphics!?</h3>
<p>Yes, CoreGraphics. Seriously, don’t run off - it’s going to be fine. Truth be told, I kind of cheated and used PaintCode for my initial graphics code. If you have never heard of <a href="http://www.paintcodeapp.com">PaintCode</a>, go to their site right now and download it. You can get a free trial that will let you use it for a limited time each session, but you can really learn a lot about CoreGraphics just by using the app.</p>

<p>In order to use CoreGraphics with our <code>CALayer</code> light, we’ll be overriding the <code>drawInContext:</code> method. It works exactly like <code>drawRect:</code> with one caveat if you would like to use UIKit methods to draw: you need to manually push the graphics context using <code>UIGraphicsPushContext(ctx)</code>.</p>

<p>The light itself consists of three distinct features:</p>

<ol>
  <li>The inactive light frame</li>
  <li>The inactive light’s base shadow (a 1/2-point down shadow)</li>
  <li>The glow of the light</li>
</ol>

<p>Each section is neatly commented and laid out for easy consumption:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/** Color Declarations &lt;em&gt;/</span>
</span><span class='line'><span class="cm">UIColor&lt;/em&gt; activeOffFill = nil;</span>
</span><span class='line'><span class="cm">if (self.lightState) {</span>
</span><span class='line'><span class="cm">    activeOffFill = self.glowColor;</span>
</span><span class='line'><span class="cm">}</span>
</span><span class='line'><span class="cm">else if(self.isActive){</span>
</span><span class='line'><span class="cm">    activeOffFill = self.activeColor;</span>
</span><span class='line'><span class="cm">}</span>
</span><span class='line'><span class="cm">else{</span>
</span><span class='line'><span class="cm">    activeOffFill = self.inactiveColor;</span>
</span><span class='line'><span class="cm">}&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">&lt;p&gt;/** Shadow Declarations &lt;em&gt;/</span>
</span><span class='line'><span class="cm">UIColor&lt;/em&gt; underStroke = underStrokeColor;</span>
</span><span class='line'><span class="cm">CGSize underStrokeOffset = CGSizeMake(0.f, 1.f/scale);</span>
</span><span class='line'><span class="cm">CGFloat underStrokeBlurRadius = 0;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">&lt;p&gt;/** Light Frame Drawing &lt;em&gt;/</span>
</span><span class='line'><span class="cm">UIBezierPath&lt;/em&gt; lightFramePath = [UIBezierPath bezierPathWithOvalInRect:lightRect];</span>
</span><span class='line'><span class="cm">CGContextSaveGState(context);</span>
</span><span class='line'><span class="cm">CGContextSetShadowWithColor(context, underStrokeOffset, underStrokeBlurRadius, underStroke.CGColor);</span>
</span><span class='line'><span class="cm">[activeOffFill setFill];</span>
</span><span class='line'><span class="cm">[lightFramePath fill];</span>
</span><span class='line'><span class="cm">CGContextRestoreGState(context);&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">&lt;p&gt;[strokeColor setStroke];</span>
</span><span class='line'><span class="cm">lightFramePath.lineWidth = 1.f/scale;</span>
</span><span class='line'><span class="cm">[lightFramePath stroke];&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">&lt;p&gt;/** Light Glow Drawing */</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">endRadius</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">lightState</span> <span class="o">?</span> <span class="n">MAX</span><span class="p">(</span><span class="n">floorf</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.f</span><span class="p">),</span> <span class="n">floorf</span><span class="p">(</span><span class="n">height</span><span class="o">/</span><span class="mf">2.f</span><span class="p">))</span> <span class="o">:</span> <span class="mf">0.f</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CGContextDrawRadialGradient</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">lightGlowGradient</span><span class="p">,</span>
</span><span class='line'>                            <span class="n">CGPointMake</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.f</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mf">2.f</span><span class="p">),</span> <span class="mf">0.f</span><span class="p">,</span>
</span><span class='line'>                            <span class="n">CGPointMake</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.f</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mf">2.f</span><span class="p">),</span> <span class="n">endRadius</span><span class="p">,</span>
</span><span class='line'>                            <span class="n">kCGGradientDrawsBeforeStartLocation</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>A bonus for using CoreGraphics in this way with properties on the layer is that CoreAnimation will implicitly animate the change in state (you will most notice this with the glow color of the light). Whenever you change a property that is used to draw the state of the light in the above code, simply call <code>setNeedsDisplay</code> in order to redraw the content.</p>

<h2 id="remaining-details">Remaining Details</h2>
<p>This will get you started on implementing a custom EQ slider on your own. The remaining details to make this look like Twitter’s version include changing the color of each light depending on its horizontal position, determining which lights are active based on the position of the slider and optimizing the drawing to only redraw lights that have changed state. I’ll leave this as an exercise to the reader, or you can check out the final product that I implemented with all of the optimizations.</p>

<p>If you’re using <code>LARSBar</code> in an app, drop me a message <a href="https://twitter.com/theonlylars">on Twitter</a> and I’ll add it to the GitHub readme.</p>
]]></content>
  </entry>
  
</feed>
